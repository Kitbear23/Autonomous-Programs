#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     GyroSensor,     sensorI2CHiTechnicGyro)
#pragma config(Sensor, S3,     IRSensor,       sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     LeftMotor,     tmotorTetrix, PIDControl)
#pragma config(Motor,  mtr_S1_C1_2,     RightMotor,    tmotorTetrix, PIDControl, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     GripperMotor,  tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     LifterMotor,   tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    LifterServo,          tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    GripperServo,         tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    ReleaseServo,         tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    GoalServo,            tServoStandard)
#pragma config(Servo,  srvo_S1_C3_5,    HookServo,            tServoStandard)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Autonomous Mode Code Template
//
// This file contains a template for simplified creation of an autonomous program for an TETRIX robot
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

#define AUTONOMOUS_MODE_COMPILE         1
#define DEBUG_AUTONOMOUS_ROTATE         0
#define DEBUG_AUTONOMOUS_TRANSLATE      0
#define DEBUG_CALC_ANGLE                0

#include "hitechnic-irseeker-v2.h"    //for IR seeker sensor

#define SERVO_STOP                    134 //The power of the servo for it to be at a complete stop
#define SERVO_RUN                      60  //The Power being put into the servos when moving
#define SAMPLE_PERIOD_MSEC             20
#define MIN_MOTOR_POWER_ROTATE         30
#define MIN_MOTOR_POWER_TRANSLATE      10//20
#define WAY_POINT_1                  9500 //8000 //in encoder counts
#define CHANGE_IN_MTR_PWR               5
#define T_CHANGE_IN_TIME               30 //30 //In Miliseconds
#define R_CHANGE_IN_TIME               10 //In Miliseconds
#define R_BRAKING_RANGE                 1
#define T_BRAKING_RANGE                 5
#define BRAKE_MTR_PWR                 -20 //-60
#define BRAKE_TIME                     60
#define ARRAY_INDEX                   500
#define ROTATE                          0
#define TRANSLATE                       1
#define ACCEL_STATE                     1
#define A_CONST_MTR_PWR_STATE           2
#define DECEL_STATE                     3
#define D_CONST_MTR_PWR_STATE           4
#define BRAKE_STATE                     5
#define AT_TARGET_STATE                 6
#define IDLE_STATE                      7
#define T_DECEL_RANGE_FACTOR          500
#define R_DECEL_RANGE_FACTOR           10
#define CM_ENCD_COUNTS                 63
#define DIST_FROM_BUCKET               37
#define LNR_FULL_MTR_PWR								1
#define LNR_FOURTH_MTR_PWR							2
#define IR_RANGE_1									 1500
#define IR_RANGE_2								   1800
#define POSITION_1									 1000
#define POSITION_2								   1000
#define POSITION_3								   1000
#define MAX_LIFTER_VALUE						 6600
#define MIN_LIFTER_VALUE					     95
#define TRANSLATE_MTR_INCREMENT					2

int BaseMode;
int SecondsToDelay;
int Path;
int nButtonPresses = 0;
//byte Position;
//byte SelectedPosition;
//int SelectedPath;
int Position = 0;
float CurrentSample = 0;
float PreviousSample = 0;
byte MaxMotorPower = 0;
float TargetAngle = 0;
int TargetPosition = 0;
bool b_TrajectoryEnabled;
int TrajectoryMode;
int TrajectoryState;
float GyroRotation = 0;
int IRSensorValue;
float DegreesThisSample = 0;
float MeasuredAngle = 0;
int i = 0;
float Offset = 0;
#if DEBUG_AUTONOMOUS_ROTATE
int R_MtrPwrArray[ARRAY_INDEX];
float AngleArray[ARRAY_INDEX];
float RotationRateArray[ARRAY_INDEX];
int Index = 0;
#endif
#if DEBUG_AUTONOMOUS_TRANSLATE
int T_MtrPwrArray[ARRAY_INDEX];
int TrajectoryStateArray[ARRAY_INDEX];
int DTTPArray[ARRAY_INDEX];
int EncoderCountsArray[ARRAY_INDEX];
int T_Index = 0;
#endif
#if DEBUG_CALC_ANGLE
float DebugArray[ARRAY_INDEX];
float DebugArray2[ARRAY_INDEX];
int DebugArray3[ARRAY_INDEX];
int Index = 0;
#endif
int DirFactor;
int LeftMotorValue;
int Encoder_Array[ARRAY_INDEX];
int IR_Array[ARRAY_INDEX];
int IR_Index = 0;

void ChooseDelay();
void ChoosePath();
void CalibrateGyro();
void ResetGyro();
void ResetEncoders();
int GetEncoderPosition();
void Rotate(long SetTargetAngle, byte SetMaxMotorPower);
void Translate(int SetTargetPosition, byte SetMaxMotorPower);
void WaitForMoveToFinish();
void LiftHook();
void LowerGrabber();
void ScoreElements_Center();
void ScoreElements_Med();

task CalculateAngle()
{
	while (true)
	{
		GyroRotation = SensorValue(GyroSensor);
		CurrentSample = GyroRotation - Offset;
		DegreesThisSample = (CurrentSample + PreviousSample)/2 * ((float)SAMPLE_PERIOD_MSEC/1000);
		MeasuredAngle = MeasuredAngle + DegreesThisSample;
		PreviousSample = CurrentSample;
#if DEBUG_CALC_ANGLE
		if(Index < ARRAY_INDEX)
		{
			DebugArray[Index] = CurrentSample;
			DebugArray2[Index] = MeasuredAngle;
			DebugArray3[Index] = time1[T1];
			Index++;
		}
#endif
		wait1Msec(SAMPLE_PERIOD_MSEC);
	}
}

task TrajectoryGenerator()
{
	int i;
	float DistanceToTargetAngle = 0;
	int DistanceToTargetPosition = 0;
	float RotateDecelRange;
	int TranslateDecelRange;

	while(true)
	{
#if DEBUG_AUTONOMOUS_ROTATE
		while(Index < 20)
		{
			if(Index < ARRAY_INDEX)
			{
				R_MtrPwrArray[Index] = motor[RightMotor];
				AngleArray[Index] = MeasuredAngle;
				RotationRateArray[Index] = CurrentSample;
				Index++;
			}
		}
#endif

		if(b_TrajectoryEnabled == true && TrajectoryMode == TRANSLATE)
		{
			///////////////////////////////////////////////
			//             AccelerateMode                //
			///////////////////////////////////////////////
			TrajectoryState = ACCEL_STATE;
			motor[RightMotor] = MIN_MOTOR_POWER_TRANSLATE*DirFactor;
			motor[LeftMotor] = motor[RightMotor];

#if DEBUG_AUTONOMOUS_TRANSLATE
			if(T_Index < ARRAY_INDEX)
			{
				T_MtrPwrArray[T_Index] = motor[RightMotor];
				TrajectoryStateArray[T_Index] = TrajectoryState;
				DTTPArray[T_Index] = DistanceToTargetPosition;
				EncoderCountsArray[T_Index] = GetEncoderPosition();
				T_Index++;
			}
#endif
			DistanceToTargetPosition = TargetPosition - GetEncoderPosition();

			for(i=MIN_MOTOR_POWER_TRANSLATE;
			i <= (MaxMotorPower - CHANGE_IN_MTR_PWR)
			&& ((DistanceToTargetPosition*DirFactor) > ((TargetPosition/2)*DirFactor))
			&& (b_TrajectoryEnabled == true);
			i = i + CHANGE_IN_MTR_PWR)
			{
				motor[RightMotor] = i*DirFactor;
				motor[LeftMotor] = motor[RightMotor];
				wait1Msec(T_CHANGE_IN_TIME);
				DistanceToTargetPosition = TargetPosition - GetEncoderPosition();
#if DEBUG_AUTONOMOUS_TRANSLATE
				if(T_Index < ARRAY_INDEX)
				{
					T_MtrPwrArray[T_Index] = motor[RightMotor];
					TrajectoryStateArray[T_Index] = TrajectoryState;
					DTTPArray[T_Index] = DistanceToTargetPosition;
					EncoderCountsArray[T_Index] = GetEncoderPosition();
					T_Index++;
				}
#endif
			}

			TranslateDecelRange = GetEncoderPosition() + (DirFactor*T_DECEL_RANGE_FACTOR);

			///////////////////////////////////////////////
			//  Constant Motor Power After Acceleration  //
			///////////////////////////////////////////////
			TrajectoryState = A_CONST_MTR_PWR_STATE;

			while((DistanceToTargetPosition*DirFactor) > (TranslateDecelRange*DirFactor)
				&& (b_TrajectoryEnabled == true))
			{
				motor[RightMotor] = i*DirFactor;
				if(nMotorEncoder(LeftMotor) < nMotorEncoder(RightMotor))
				{
					motor[LeftMotor] = motor[RightMotor] + TRANSLATE_MTR_INCREMENT;
					LeftMotorValue = motor[LeftMotor];
				}
				else if(nMotorEncoder(LeftMotor) > nMotorEncoder(RightMotor))
				{
					motor[LeftMotor] = motor[RightMotor] - TRANSLATE_MTR_INCREMENT;
					LeftMotorValue = motor[LeftMotor];
				}
				else
				{
					motor[LeftMotor] = motor[RightMotor];
					LeftMotorValue = motor[LeftMotor];
				}
				wait1Msec(T_CHANGE_IN_TIME);
				DistanceToTargetPosition = TargetPosition - GetEncoderPosition();
#if DEBUG_AUTONOMOUS_TRANSLATE
				if(T_Index < ARRAY_INDEX)
				{
					T_MtrPwrArray[T_Index] = motor[RightMotor];
					TrajectoryStateArray[T_Index] = TrajectoryState;
					DTTPArray[T_Index] = DistanceToTargetPosition;
					EncoderCountsArray[T_Index] = GetEncoderPosition();
					T_Index++;
				}
#endif
			}

			///////////////////////////////////////////////
			//             Decelerate                    //
			///////////////////////////////////////////////
			TrajectoryState = DECEL_STATE;

			for(;
			(i > MIN_MOTOR_POWER_TRANSLATE) && ((DistanceToTargetPosition*DirFactor) > T_BRAKING_RANGE)
			&& (b_TrajectoryEnabled == true);
			i = i - CHANGE_IN_MTR_PWR
			)
			{
				motor[RightMotor] = i*DirFactor;
				motor[LeftMotor] = motor[RightMotor];
				wait1Msec(T_CHANGE_IN_TIME);
				DistanceToTargetPosition = TargetPosition - GetEncoderPosition();
#if DEBUG_AUTONOMOUS_TRANSLATE
				if(T_Index < ARRAY_INDEX)
				{
					T_MtrPwrArray[T_Index] = motor[RightMotor];
					TrajectoryStateArray[T_Index] = TrajectoryState;
					DTTPArray[T_Index] = DistanceToTargetPosition;
					EncoderCountsArray[T_Index] = GetEncoderPosition();
					T_Index++;
				}
#endif
			}

			///////////////////////////////////////////////
			//  Constant Motor Power After Deceleration  //
			///////////////////////////////////////////////
			TrajectoryState = D_CONST_MTR_PWR_STATE;

			while(((DistanceToTargetPosition*DirFactor) > T_BRAKING_RANGE)
				&& (b_TrajectoryEnabled == true))
			{
				wait1Msec(T_CHANGE_IN_TIME);
				DistanceToTargetPosition = TargetPosition - GetEncoderPosition();
#if DEBUG_AUTONOMOUS_TRANSLATE
				if(T_Index < ARRAY_INDEX)
				{
					T_MtrPwrArray[T_Index] = motor[RightMotor];
					TrajectoryStateArray[T_Index] = TrajectoryState;
					DTTPArray[T_Index] = DistanceToTargetPosition;
					EncoderCountsArray[T_Index] = GetEncoderPosition();
					T_Index++;
				}
#endif
			}

			///////////////////////////////////////////////
			//                   Brake                   //
			///////////////////////////////////////////////
			TrajectoryState = BRAKE_STATE;

			motor[RightMotor] = BRAKE_MTR_PWR*DirFactor;
			motor[LeftMotor] = motor[RightMotor];
			wait1Msec(BRAKE_TIME);
			DistanceToTargetPosition = TargetPosition - GetEncoderPosition();
#if DEBUG_AUTONOMOUS_TRANSLATE
			if(T_Index < ARRAY_INDEX)
			{
				T_MtrPwrArray[T_Index] = motor[RightMotor];
				TrajectoryStateArray[T_Index] = TrajectoryState;
				DTTPArray[T_Index] = DistanceToTargetPosition;
				EncoderCountsArray[T_Index] = GetEncoderPosition();
				T_Index++;
			}
#endif

			///////////////////////////////////////////////
			//              At Target Position           //
			///////////////////////////////////////////////
			TrajectoryState = AT_TARGET_STATE;

			motor[RightMotor] = 0;
			motor[LeftMotor] = 0;

			b_TrajectoryEnabled = false;

#if DEBUG_AUTONOMOUS_TRANSLATE
			if(T_Index < ARRAY_INDEX)
			{
				T_MtrPwrArray[T_Index] = motor[RightMotor];
				TrajectoryStateArray[T_Index] = TrajectoryState;
				DTTPArray[T_Index] = DistanceToTargetPosition;
				EncoderCountsArray[T_Index] = GetEncoderPosition();
				T_Index++;
			}
#endif
		}

		else if(b_TrajectoryEnabled == true && TrajectoryMode == ROTATE)
		{
			motor[LeftMotor] = MIN_MOTOR_POWER_ROTATE*DirFactor;
			motor[RightMotor] = -motor[LeftMotor];

			clearTimer(T1);

#if DEBUG_AUTONOMOUS_ROTATE
			if(Index < ARRAY_INDEX)
			{
				R_MtrPwrArray[Index] = motor[RightMotor];
				AngleArray[Index] = MeasuredAngle;
				RotationRateArray[Index] = CurrentSample;
				Index++;
			}
#endif
			DistanceToTargetAngle = TargetAngle - MeasuredAngle;

			///////////////////////////////////////////////
			//             Accelerate                    //
			///////////////////////////////////////////////
			TrajectoryState = ACCEL_STATE;

			for(i=MIN_MOTOR_POWER_ROTATE;
			i <= (MaxMotorPower - CHANGE_IN_MTR_PWR)
			&& ((DistanceToTargetAngle*DirFactor) > (TargetAngle/2*DirFactor))
			&& (b_TrajectoryEnabled == true);
			i = i + CHANGE_IN_MTR_PWR)
			{
				motor[LeftMotor] = i*DirFactor;
				motor[RightMotor] = -motor[LeftMotor];
				wait1Msec(R_CHANGE_IN_TIME);
				DistanceToTargetAngle = TargetAngle - MeasuredAngle;

#if DEBUG_AUTONOMOUS_ROTATE
				if(Index < ARRAY_INDEX)
				{
					R_MtrPwrArray[Index] = motor[RightMotor];
					AngleArray[Index] = MeasuredAngle;
					RotationRateArray[Index] = CurrentSample;
					Index++;
				}
#endif
			}

			RotateDecelRange = MeasuredAngle + (DirFactor*R_DECEL_RANGE_FACTOR);

			///////////////////////////////////////////////
			//  Constant Motor Power After Acceleration  //
			///////////////////////////////////////////////
			TrajectoryState = A_CONST_MTR_PWR_STATE;

			while((DistanceToTargetAngle*DirFactor) > (RotateDecelRange*DirFactor)
				&& (b_TrajectoryEnabled == true))
			{
				motor[LeftMotor] = i*DirFactor;
				motor[RightMotor] = -motor[LeftMotor];
				wait1Msec(R_CHANGE_IN_TIME);
				DistanceToTargetAngle = TargetAngle - MeasuredAngle;
#if DEBUG_AUTONOMOUS_ROTATE
				if(Index < ARRAY_INDEX)
				{
					R_MtrPwrArray[Index] = motor[RightMotor];
					AngleArray[Index] = MeasuredAngle;
					RotationRateArray[Index] = CurrentSample;
					Index++;
				}
#endif
			}

			///////////////////////////////////////////////
			//             Decelerate                    //
			///////////////////////////////////////////////
			TrajectoryState = DECEL_STATE;

			for(;
			(i > MIN_MOTOR_POWER_ROTATE)
			&& ((DistanceToTargetAngle*DirFactor) > R_BRAKING_RANGE)
			&& (b_TrajectoryEnabled == true);
			i = i - CHANGE_IN_MTR_PWR)
			{
				motor[LeftMotor] = i*DirFactor;
				motor[RightMotor] = -motor[LeftMotor];
				wait1Msec(R_CHANGE_IN_TIME);

				DistanceToTargetAngle = TargetAngle - MeasuredAngle;

#if DEBUG_AUTONOMOUS_ROTATE
				if(Index < ARRAY_INDEX)
				{
					R_MtrPwrArray[Index] = motor[RightMotor];
					AngleArray[Index] = MeasuredAngle;
					RotationRateArray[Index] = CurrentSample;
					Index++;
				}
#endif
			}

			///////////////////////////////////////////////
			//  Constant Motor Power After Deceleration  //
			///////////////////////////////////////////////
			TrajectoryState = D_CONST_MTR_PWR_STATE;

			while((DistanceToTargetAngle*DirFactor) > R_BRAKING_RANGE
				&& (b_TrajectoryEnabled == true))
			{
				wait1Msec(R_CHANGE_IN_TIME);

				DistanceToTargetAngle = TargetAngle - MeasuredAngle;

#if DEBUG_AUTONOMOUS_ROTATE
				if(Index < ARRAY_INDEX)
				{
					R_MtrPwrArray[Index] = motor[RightMotor];
					AngleArray[Index] = MeasuredAngle;
					RotationRateArray[Index] = CurrentSample;
					Index++;
				}
#endif
			}

			///////////////////////////////////////////////
			//                   Brake                   //
			///////////////////////////////////////////////
			TrajectoryState = BRAKE_STATE;

			motor[LeftMotor] = BRAKE_MTR_PWR*DirFactor;
			motor[RightMotor] = -motor[LeftMotor];
			wait1Msec(BRAKE_TIME);

			DistanceToTargetAngle = TargetAngle - MeasuredAngle;

#if DEBUG_AUTONOMOUS_ROTATE
			if(Index < ARRAY_INDEX)
			{
				R_MtrPwrArray[Index] = motor[RightMotor];
				AngleArray[Index] = MeasuredAngle;
				RotationRateArray[Index] = CurrentSample;
				Index++;
			}
#endif

			///////////////////////////////////////////////
			//              At Target Position           //
			///////////////////////////////////////////////
			TrajectoryState = AT_TARGET_STATE;

			motor[RightMotor] = 0;
			motor[LeftMotor] = 0;

			b_TrajectoryEnabled = false;

#if DEBUG_AUTONOMOUS_ROTATE
			if(Index < ARRAY_INDEX)
			{
				R_MtrPwrArray[Index] = motor[RightMotor];
				AngleArray[Index] = MeasuredAngle;
				RotationRateArray[Index] = CurrentSample;
				Index++;
			}
#endif
		}
		else //b_TrajectoryEnabled == false
		{
			TrajectoryState = IDLE_STATE;

#if DEBUG_AUTONOMOUS_ROTATE
			if(Index < ARRAY_INDEX)
			{
				R_MtrPwrArray[Index] = motor[RightMotor];
				AngleArray[Index] = MeasuredAngle;
				RotationRateArray[Index] = CurrentSample;
				Index++;
			}
#endif
#if DEBUG_AUTONOMOUS_TRANSLATE
			if(T_Index < ARRAY_INDEX)
			{
				T_MtrPwrArray[T_Index] = motor[RightMotor];
				TrajectoryStateArray[T_Index] = TrajectoryState;
				DTTPArray[T_Index] = DistanceToTargetPosition;
				EncoderCountsArray[T_Index] = GetEncoderPosition();
				T_Index++;
			}
#endif
			wait1Msec(T_CHANGE_IN_TIME);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of autonomous mode, you may want to perform some initialization on your robot.
// Things that might be performed during initialization include:
//   1. Move motors and servos to a preset position.
//   2. Some sensor types take a short while to reach stable values during which time it is best that
//      robot is not moving. For example, gyro sensor needs a few seconds to obtain the background
//      "bias" value.
//
// In many cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
	ResetGyro();
	CalibrateGyro();
	nMotorEncoder(LifterMotor) = 0;
	servo(LifterServo) = 33; //Starting Value
	servo(GoalServo) = 255;
	servo(GripperServo) = 142;
	servo(ReleaseServo) = 30;
	servo(HookServo) = 0;
	motor[LeftMotor] = 0;
	motor[RightMotor] = 0;
	BaseMode = LNR_FULL_MTR_PWR;


	ChooseDelay();
	ChoosePath();

	return;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the autonomous robot operation. Customize as appropriate for
// your specific robot.
//
// The types of things you might do during the autonomous phase (for the 2008-9 FTC competition)
// are:
//
//   1. Have the robot follow a line on the game field until it reaches one of the puck storage
//      areas.
//   2. Load pucks into the robot from the storage bin.
//   3. Stop the robot and wait for autonomous phase to end.
//
// This simple template does nothing except play a periodic tone every few seconds.
//
// At the end of the autonomous period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{
	initializeRobot();

	waitForStart(); // Wait for the beginning of autonomous phase.

	clearTimer(T1);
	clearDebugStream();

	startTask(CalculateAngle, 255);
	startTask(TrajectoryGenerator, 90);

	wait1Msec(SecondsToDelay);

	switch (Path)
	{
	case 1:
		Translate(-2500, 40); //-4100
		WaitForMoveToFinish();

		wait1Msec(500);

		Rotate(78, 30); //Turn Right
		WaitForMoveToFinish();

		wait1Msec(1000);

		Translate(-2800, 10); //20

		while(b_TrajectoryEnabled == true)
		{
			IRSensorValue = SensorValue[IRSensor];
			if(IR_Index < ARRAY_INDEX)
			{
				Encoder_Array[IR_Index] = nMotorEncoder[RightMotor];
				IR_Array[IR_Index] = SensorValue[IRSensor];
				IR_Index++;
			}
			if(IRSensorValue == 8)
			{
				wait1Msec(500);
				// Abort Move
				b_TrajectoryEnabled = false;

				// Wait some time to make sure robot is stopped
				// before reading position.
				wait1Msec(1000);

				Position = nMotorEncoder(RightMotor); //check left encoder for pos 1 & 2        
			}
			else
				{
				wait1Msec(20);
				Position = nMotorEncoder(RightMotor);
			}
		}
		
		if(abs(Position) > 2600)
		{
			//Do nothing
		}
		if(abs(Position) <= IR_RANGE_1)
		{
			if(abs(Position) > 1100)
			{
				if(abs(Position) < 1200)
				{					
					Translate(800, 30);
					WaitForMoveToFinish();
				}
				else if(abs(Position) < 1300)
				{
					Translate(890, 30);
					WaitForMoveToFinish();
				}
				else if(abs(Position) < 1400)
				{
					Translate(960, 30);
					WaitForMoveToFinish();
				}
				else if(abs(Position) < 1500)
				{
					Translate(1050, 30);
					WaitForMoveToFinish();
				}
				else
				{
					Translate(710, 30);
					WaitForMoveToFinish();
				}
			}
			wait1Msec(200);

			Rotate(-55, 30);//84
			WaitForMoveToFinish();

			wait1Msec(500);
			
			LiftHook();
			
			wait1Msec(500);

			Translate(-1225, 30);
			WaitForMoveToFinish();

			Rotate(-25, 30);//84
			WaitForMoveToFinish();

			wait1Msec(500);

			Translate(1700, 50);
			WaitForMoveToFinish();
		}
		else if(abs(Position) > IR_RANGE_1 && abs(Position) <= IR_RANGE_2)
		{

			Translate(-500, 20);
			WaitForMoveToFinish();

			wait1Msec(500);

			Rotate(-78, 30);
			WaitForMoveToFinish();

			wait1Msec(500);

			Translate(-960, 30); //910
			WaitForMoveToFinish();
			
			LiftHook();
			
			Rotate(-35, 30);//84
			WaitForMoveToFinish();

			wait1Msec(200);
			
			Translate(-500, 30); //600
			WaitForMoveToFinish();

			Rotate(-25, 30);//84
			WaitForMoveToFinish();

			wait1Msec(200);

			Translate(1300, 40);
			WaitForMoveToFinish();
		}
		else //Position > IR_RANGE_2 (IR_RANGE_3)
		{
		Translate(-780, 30);
		WaitForMoveToFinish();
		
		wait1Msec(200);

		Rotate(-79, 30); //Turn Left
		WaitForMoveToFinish();
		
		wait1Msec(200);

		Translate(-2100, 30);
		WaitForMoveToFinish();

		wait1Msec(200);

		Rotate(-45, 30);
		WaitForMoveToFinish();

		/*LiftHook();

		wait1Msec(200);

		Translate(-700, 30);
		WaitForMoveToFinish();

		wait1Msec(200);

		Rotate(-30, 30);
		WaitForMoveToFinish();

		wait1Msec(200);

		Translate(1500, 40);
		WaitForMoveToFinish();*/
		}

		break;

	case 2:
		//Score in Center Goal

		Translate(-2500, 40); //-4100
		WaitForMoveToFinish();

		wait1Msec(500);

		Rotate(78, 30); //Turn Right
		WaitForMoveToFinish();

		wait1Msec(1000);

		Translate(-2800, 20); //20

		while(b_TrajectoryEnabled == true)
		{
			if(IRSensorValue == 8 || IRSensorValue == 7)
			{
				wait1Msec(500);
				// Abort Move
				b_TrajectoryEnabled = false;

				// Wait some time to make sure robot is stopped
				// before reading position.
				wait1Msec(1000);

				Position = nMotorEncoder(LeftMotor);
			}
			else
			{
				wait1Msec(500);
				Position = nMotorEncoder(LeftMotor);
			}
		}
		if(abs(Position) > 2600)
		{
			//Do nothing
		}
		else if(abs(Position) <= IR_RANGE_1)
		{
			Translate(POSITION_1, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			Rotate(90, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			Translate(1500, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			Rotate(-90, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			Translate(-300, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			ScoreElements_Center();

			wait1Msec(200);

			Rotate(-90, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			Translate(1500, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			Rotate(90, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			Translate(-POSITION_1, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			//Release the Cascade

			Translate(700, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			LiftHook();

			Rotate(-55, 30);
			WaitForMoveToFinish();

			wait1Msec(500);

			Translate(-990, 30);
			WaitForMoveToFinish();

			Rotate(-32, 30);//84
			WaitForMoveToFinish();

			wait1Msec(700);

			Translate(3800, 70);
			WaitForMoveToFinish();
		}
		else if(abs(Position) > IR_RANGE_1 && abs(Position) <= IR_RANGE_2)
		{

			//Score in Center Goal

			Translate(POSITION_2, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			Rotate(45, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			Translate(1500, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			Rotate(-90, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			Translate(-300, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			ScoreElements_Center();

			wait1Msec(200);

			Rotate(-90, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			Translate(1500, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			Rotate(135, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			Translate(-POSITION_2, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			//Release the Cascade

			Translate(-500, 20);
			WaitForMoveToFinish();

			wait1Msec(200);

			Rotate(-90, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			Translate(-1200, 30);
			WaitForMoveToFinish();

			LiftHook();

			wait1Msec(200);

			Rotate(-25, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			Translate(3000, 50);
			WaitForMoveToFinish();
		}
		else //Position 3
		{
			//Score in Center Goal

			Translate(POSITION_3, 50);
			WaitForMoveToFinish();

			wait1Msec(200);

			Rotate(-90, 50);
			WaitForMoveToFinish();

			wait1Msec(200);

			Translate(-300, 50);
			WaitForMoveToFinish();

			wait1Msec(200);

			ScoreElements_Center();

			wait1Msec(200);

			Rotate(90, 50);
			WaitForMoveToFinish();

			wait1Msec(200);

			Translate(-POSITION_3, 50);
			WaitForMoveToFinish();

			wait1Msec(200);

			//Release the Cascade

			Translate(-580, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			Rotate(-85, 30); //Turn Left
			WaitForMoveToFinish();

			wait1Msec(200);

			Translate(-2100, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			Rotate(-45, 30);
			WaitForMoveToFinish();

			LiftHook();

			wait1Msec(200);

			Translate(-700, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			Rotate(-30, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			Translate(1500, 50);
			WaitForMoveToFinish();
		}

		break;

	case 3:

		//Score in Center Goal

		Translate(-4100, 50);
		WaitForMoveToFinish();

		wait1Msec(500);

		Rotate(80, 50); //Turn Right
		WaitForMoveToFinish();

		wait1Msec(1000);

		Translate(-5000, 15); //20

		while(b_TrajectoryEnabled == true)
		{
			if(IRSensorValue == 8)
			{
				wait1Msec(500);
				// Abort Move
				b_TrajectoryEnabled = false;

				// Wait some time to make sure robot is stopped
				// before reading position.
				wait1Msec(1000);

				Position = nMotorEncoder(LeftMotor);
			}
			else
			{
				wait1Msec(500);
				Position = nMotorEncoder(LeftMotor);
			}
		}
		if(abs(Position) > 4800)
		{
			//Do nothing
		}
		else if(abs(Position) <= IR_RANGE_1)
		{
			Translate(POSITION_1, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			Rotate(90, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			Translate(1500, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			Rotate(-90, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			Translate(-300, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			ScoreElements_Center();
		}
		else if(abs(Position) > IR_RANGE_1 && abs(Position) <= IR_RANGE_2)
		{

			//Score in Center Goal

			Translate(POSITION_2, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			Rotate(45, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			Translate(1500, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			Rotate(-90, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			Translate(-300, 30);
			WaitForMoveToFinish();

			wait1Msec(200);

			ScoreElements_Center();
		}
		else //Position 3
		{
			//Score in Center Goal

			Translate(POSITION_3, 50);
			WaitForMoveToFinish();

			wait1Msec(200);

			Rotate(-90, 50);
			WaitForMoveToFinish();

			wait1Msec(200);

			Translate(-300, 50);
			WaitForMoveToFinish();

			wait1Msec(200);

			ScoreElements_Center();
		}

		break;

	case 4:
		Translate(-3000, 20);
		WaitForMoveToFinish();

		break;

	case 5:
		Translate(-4000, 20);
		WaitForMoveToFinish();

		wait1Msec(200);

		LowerGrabber();

		ScoreElements_Med();

		break;

	case 6:
		Translate(-4000, 20);
		WaitForMoveToFinish();

		wait1Msec(200);

		LowerGrabber();

		ScoreElements_Med();

		Translate(500, 30);
		WaitForMoveToFinish();

		wait1Msec(200);

		Rotate(90, 30);
		WaitForMoveToFinish();

		wait1Msec(200);

		Translate(3000, 30);
		WaitForMoveToFinish();

		wait1Msec(200);

		Rotate(-90, 30);
		WaitForMoveToFinish();

		wait1Msec(200);

		Translate(5000, 30);
		WaitForMoveToFinish();

		wait1Msec(200);

		Rotate(-90, 30);
		WaitForMoveToFinish();

		break;

	case 7:
		Translate(-3000, 20);
		WaitForMoveToFinish();

		wait1Msec(200);

		Rotate(90, 30);
		WaitForMoveToFinish();

		wait1Msec(200);

		Translate(1000, 30);
		WaitForMoveToFinish();

		wait1Msec(200);

		Rotate(90, 30);
		WaitForMoveToFinish();

		wait1Msec(200);

		Translate(4000, 30);
		WaitForMoveToFinish();

		wait1Msec(200);

		Rotate(-90, 30);
		WaitForMoveToFinish();

		wait1Msec(200);

		Translate(-1000, 30);
		WaitForMoveToFinish();

		wait1Msec(200);

		LowerGrabber();

		ScoreElements_Med();

		break;

	default:
		Translate(-3000, 20);
		WaitForMoveToFinish();

		wait1Msec(200);

		Rotate(90, 30);
		WaitForMoveToFinish();

		wait1Msec(200);

		Translate(1000, 30);
		WaitForMoveToFinish();

		wait1Msec(200);

		Rotate(90, 30);
		WaitForMoveToFinish();

		wait1Msec(200);

		Translate(4000, 30);
		WaitForMoveToFinish();

		wait1Msec(200);

		Rotate(-90, 30);
		WaitForMoveToFinish();

		wait1Msec(200);

		Translate(-1000, 30);
		WaitForMoveToFinish();

		wait1Msec(200);

		LowerGrabber();

		ScoreElements_Med();

		wait1Msec(200);

		Translate(1000, 30);
		WaitForMoveToFinish();

		wait1Msec(200);

		Rotate(-90, 30);
		WaitForMoveToFinish();

		wait1Msec(200);

		Translate(5000, 30);
		WaitForMoveToFinish();

		wait1Msec(200);

		Rotate(-90, 30);
		WaitForMoveToFinish();

		wait1Msec(200);
	}
	for(IR_Index=0; IR_Index<ARRAY_INDEX; IR_Index++)
	{
		wait1Msec(10);
		writeDebugStream("%d,", Encoder_Array[IR_Index]);
		wait1Msec(10);
		writeDebugStream("%d\n,", IR_Array[IR_Index]);
		wait1Msec(10);
	}

#if DEBUG_AUTONOMOUS_ROTATE
	for(Index=0; Index<ARRAY_INDEX; Index++)
	{
		wait1Msec(10);
		writeDebugStream("%d,", R_MtrPwrArray[Index]);
		wait1Msec(10);
		writeDebugStream("%f,", AngleArray[Index]);
		wait1Msec(10);
		writeDebugStream("%f\n", RotationRateArray[Index]);
	}
#endif

}

void CalibrateGyro()
{
	for(i = 0; i<20;i++)
	{
		wait1Msec(10);
		Offset = Offset + SensorValue(GyroSensor);
	}
	Offset = Offset/20;
}

void ResetGyro()
{
	b_TrajectoryEnabled = false;
	TargetAngle = 0;
	CurrentSample = 0;
	PreviousSample = 0;
	MeasuredAngle = 0;
}

void Rotate(long SetTargetAngle, byte SetMaxMotorPower)
{
	ResetGyro();
	TargetAngle = SetTargetAngle;
	MaxMotorPower = SetMaxMotorPower;
	b_TrajectoryEnabled = true;
	TrajectoryMode = ROTATE;

	if(TargetAngle < 0)
	{
		DirFactor = -1;
	}
	else // TargetAngle > 0
	{
		DirFactor = 1;
	}
}

void ResetEncoders()
{
	b_TrajectoryEnabled = false;
	TargetPosition = 0;
	nMotorEncoder[RightMotor] = 0;
	nMotorEncoder[LeftMotor] = 0;
}

int GetEncoderPosition()
{
		IRSensorValue = SensorValue[IRSensor];
	return nMotorEncoder[RightMotor];
}

void Translate(int SetTargetPosition, byte SetMaxMotorPower)
{
	ResetEncoders();
	TargetPosition = SetTargetPosition;
	MaxMotorPower = SetMaxMotorPower;
	b_TrajectoryEnabled = true;
	TrajectoryMode = TRANSLATE;

	if(TargetPosition < 0)
	{
		DirFactor = -1;
	}
	else // TargetPosition > 0
	{
		DirFactor = 1;
	}
}

void WaitForMoveToFinish()
{
	while(b_TrajectoryEnabled == true)
	{
		wait1Msec(10);
	}
}

void ChooseDelay()
{
	nButtonPresses = 0;
	eraseDisplay();

	while(nNxtButtonPressed != 3)
	{

		displayCenteredTextLine(1, "Delay Time?");

		displayCenteredBigTextLine(3, "%d", nButtonPresses);

		if(nNxtButtonPressed == 1)
		{
			nButtonPresses += 1;
			displayCenteredBigTextLine(3, "%d", nButtonPresses);
			while(nNxtButtonPressed != -1)//wait for release
			{
				//do nothing
			}
		}

		if(nNxtButtonPressed == 2)
		{
			nButtonPresses -= 1;
			displayCenteredBigTextLine(3, "%d", nButtonPresses);
			while(nNxtButtonPressed != -1)//wait for release
			{
				//do nothing
			}
		}
	}

	SecondsToDelay = nButtonPresses*1000;

	eraseDisplay();

	displayCenteredBigTextLine(3, "%d", SecondsToDelay);

	wait1Msec(1000);

	eraseDisplay();

	return;
}

void ChoosePath()
{
	nButtonPresses = 0;
	eraseDisplay();

	while(nNxtButtonPressed != 3)
	{

		displayCenteredTextLine(1, "Which Path?");

		displayCenteredBigTextLine(3, "%d", nButtonPresses);

		if(nNxtButtonPressed == 1)
		{
			nButtonPresses += 1;
			displayCenteredBigTextLine(3, "%d", nButtonPresses);
			while(nNxtButtonPressed != -1)//wait for release
			{
				//do nothing
			}
		}

		if(nNxtButtonPressed == 2)
		{
			nButtonPresses -= 1;
			displayCenteredBigTextLine(3, "%d", nButtonPresses);
			while(nNxtButtonPressed != -1)//wait for release
			{
				//do nothing
			}
		}
	}

	Path = nButtonPresses;

	eraseDisplay();

	displayCenteredBigTextLine(3, "%d", Path);

	wait1Msec(1000);

	eraseDisplay();

	return;
}

void LiftHook()
{
	servo[HookServo] = 95;
	wait1Msec(400);
}

void LowerGrabber()
{
	servo[GoalServo] = 145;
	wait1Msec(500);
}

void ScoreElements_Center()
{
	nMotorEncoder[LifterMotor] = 0;

	//Lift Slides

	nMotorEncoderTarget[LifterMotor] = 2000;

	motor[LifterMotor] = 100;

	while(nMotorRunState(LifterMotor) != runStateIdle)
	{
		//wait til finished
	}

	motor[LifterMotor] = 0;

	//Dump elements

	servo(LifterServo) = 200;

	wait1Msec(1500);

	servo(LifterServo) = 0;

	wait1Msec(200);

	//Lower Slides

	nMotorEncoderTarget[LifterMotor] = MIN_LIFTER_VALUE;

	motor[LifterMotor] = -10;

	while(nMotorRunState(LifterMotor) != runStateIdle)
	{
		//wait til finished
	}

	motor[LifterMotor] = 0;

	//Move Forward

	wait1Msec(200);

	Translate(300, 20);
	WaitForMoveToFinish();
}

void ScoreElements_Med()
{
	nMotorEncoder[LifterMotor] = 0;

	//Lift Slides

	nMotorEncoderTarget[LifterMotor] = 1000;

	motor[LifterMotor] = 100;

	while(nMotorRunState(LifterMotor) != runStateIdle)
	{
		//wait til finished
	}

	motor[LifterMotor] = 0;

	//Dump elements

	servo(LifterServo) = 255;

	wait1Msec(1500);

	servo(LifterServo) = 33;

	wait1Msec(200);

	//Lower Slides

	nMotorEncoderTarget[LifterMotor] = MIN_LIFTER_VALUE;

	motor[LifterMotor] = -10;

	while(nMotorRunState(LifterMotor) != runStateIdle)
	{
		//wait til finished
	}

	motor[LifterMotor] = 0;

	//Move Forward

	wait1Msec(200);

	Translate(300, 20);
	WaitForMoveToFinish();
}
