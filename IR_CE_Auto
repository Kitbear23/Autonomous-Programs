#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S2,     IRSensor,       sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     GyroSensor,     sensorI2CHiTechnicGyro)
#pragma config(Motor,  mtr_S1_C1_1,     LeftMotor,     tmotorTetrix, PIDControl)
#pragma config(Motor,  mtr_S1_C1_2,     RightMotor,    tmotorTetrix, PIDControl, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     GripperMotor,  tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     LifterMotor,   tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    LifterServo,          tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    GripperServo,         tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    GoalServo,            tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    HookServo,            tServoStandard)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Autonomous Mode Code Template
//
// This file contains a template for simplified creation of an autonomous program for an TETRIX robot
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

#define AUTONOMOUS_MODE_COMPILE         1
#define DEBUG_AUTONOMOUS_ROTATE         0
#define DEBUG_AUTONOMOUS_TRANSLATE      0
#define DEBUG_CALC_ANGLE                0

#include "hitechnic-irseeker-v2.h"    //for IR seeker sensor

#define SERVO_STOP                    134 //The power of the servo for it to be at a complete stop
#define SERVO_RUN                      60  //The Power being put into the servos when moving
#define SAMPLE_PERIOD_MSEC             20
#define MIN_MOTOR_POWER_ROTATE         30
#define MIN_MOTOR_POWER_TRANSLATE      30
#define WAY_POINT_1                  9500 //8000 //in encoder counts
#define CHANGE_IN_MTR_PWR               5
#define T_CHANGE_IN_TIME               30 //In Miliseconds
#define R_CHANGE_IN_TIME               10 //In Miliseconds
#define R_BRAKING_RANGE                 1
#define T_BRAKING_RANGE                 5
#define BRAKE_MTR_PWR                 -60
#define BRAKE_TIME                     60
#define ARRAY_INDEX                    50
#define ROTATE                          0
#define TRANSLATE                       1
#define ACCEL_STATE                     1
#define A_CONST_MTR_PWR_STATE           2
#define DECEL_STATE                     3
#define D_CONST_MTR_PWR_STATE           4
#define BRAKE_STATE                     5
#define AT_TARGET_STATE                 6
#define IDLE_STATE                      7
#define T_DECEL_RANGE_FACTOR          500
#define R_DECEL_RANGE_FACTOR           10
#define CM_ENCD_COUNTS                 63
#define DIST_FROM_BUCKET               37
#define LNR_FULL_MTR_PWR								1
#define LNR_FOURTH_MTR_PWR							2
#define IR_RANGE_1										 3700
#define IR_RANGE_2										 3150

int BaseMode;
int SecondsToDelay;
int nButtonPresses = 0;
//byte Position;
//byte SelectedPosition;
//int SelectedPath;
int Position = 0;
float CurrentSample = 0;
float PreviousSample = 0;
byte MaxMotorPower = 0;
float TargetAngle = 0;
int TargetPosition = 0;
bool b_TrajectoryEnabled;
int TrajectoryMode;
int TrajectoryState;
float GyroRotation = 0;
int IRSensorValue;
float DegreesThisSample = 0;
float MeasuredAngle = 0;
int i = 0;
float Offset = 0;
#if DEBUG_AUTONOMOUS_ROTATE
int R_MtrPwrArray[ARRAY_INDEX];
float AngleArray[ARRAY_INDEX];
float RotationRateArray[ARRAY_INDEX];
int Index = 0;
#endif
#if DEBUG_AUTONOMOUS_TRANSLATE
int T_MtrPwrArray[ARRAY_INDEX];
int TrajectoryStateArray[ARRAY_INDEX];
int DTTPArray[ARRAY_INDEX];
int EncoderCountsArray[ARRAY_INDEX];
int T_Index = 0;
#endif
#if DEBUG_CALC_ANGLE
float DebugArray[ARRAY_INDEX];
float DebugArray2[ARRAY_INDEX];
int DebugArray3[ARRAY_INDEX];
int Index = 0;
#endif
int DirFactor;

void ChooseDelay();
void CalibrateGyro();
void ResetGyro();
void ResetEncoders();
int GetEncoderPosition();
void Rotate(long SetTargetAngle, byte SetMaxMotorPower);
void Translate(int SetTargetPosition, byte SetMaxMotorPower);
void WaitForMoveToFinish();
void LiftHook();

task CalculateAngle()
{
	while (true)
	{
		GyroRotation = SensorValue(GyroSensor);
		CurrentSample = GyroRotation - Offset;
		DegreesThisSample = (CurrentSample + PreviousSample)/2 * ((float)SAMPLE_PERIOD_MSEC/1000);
		MeasuredAngle = MeasuredAngle + DegreesThisSample;
		PreviousSample = CurrentSample;
#if DEBUG_CALC_ANGLE
		if(Index < ARRAY_INDEX)
		{
			DebugArray[Index] = CurrentSample;
			DebugArray2[Index] = MeasuredAngle;
			DebugArray3[Index] = time1[T1];
			Index++;
		}
#endif
		wait1Msec(SAMPLE_PERIOD_MSEC);
	}
}

task TrajectoryGenerator()
{
	int i;
	float DistanceToTargetAngle = 0;
	int DistanceToTargetPosition = 0;
	float RotateDecelRange;
	int TranslateDecelRange;

	while(true)
	{
#if DEBUG_AUTONOMOUS_ROTATE
		while(Index < 20)
		{
			if(Index < ARRAY_INDEX)
			{
				R_MtrPwrArray[Index] = motor[RightMotor];
				AngleArray[Index] = MeasuredAngle;
				RotationRateArray[Index] = CurrentSample;
				Index++;
			}
		}
#endif

		if(b_TrajectoryEnabled == true && TrajectoryMode == TRANSLATE)
		{
			///////////////////////////////////////////////
			//             AccelerateMode                //
			///////////////////////////////////////////////
			TrajectoryState = ACCEL_STATE;
			motor[RightMotor] = MIN_MOTOR_POWER_TRANSLATE*DirFactor;
			motor[LeftMotor] = motor[RightMotor];

#if DEBUG_AUTONOMOUS_TRANSLATE
			if(T_Index < ARRAY_INDEX)
			{
				T_MtrPwrArray[T_Index] = motor[RightMotor];
				TrajectoryStateArray[T_Index] = TrajectoryState;
				DTTPArray[T_Index] = DistanceToTargetPosition;
				EncoderCountsArray[T_Index] = GetEncoderPosition();
				T_Index++;
			}
#endif
			DistanceToTargetPosition = TargetPosition - GetEncoderPosition();

			for(i=MIN_MOTOR_POWER_TRANSLATE;
			i <= (MaxMotorPower - CHANGE_IN_MTR_PWR)
			&& ((DistanceToTargetPosition*DirFactor) > ((TargetPosition/2)*DirFactor))
			&& (b_TrajectoryEnabled == true);
			i = i + CHANGE_IN_MTR_PWR)
			{
				motor[RightMotor] = i*DirFactor;
				motor[LeftMotor] = motor[RightMotor];
				wait1Msec(T_CHANGE_IN_TIME);
				DistanceToTargetPosition = TargetPosition - GetEncoderPosition();
#if DEBUG_AUTONOMOUS_TRANSLATE
				if(T_Index < ARRAY_INDEX)
				{
					T_MtrPwrArray[T_Index] = motor[RightMotor];
					TrajectoryStateArray[T_Index] = TrajectoryState;
					DTTPArray[T_Index] = DistanceToTargetPosition;
					EncoderCountsArray[T_Index] = GetEncoderPosition();
					T_Index++;
				}
#endif
			}

			TranslateDecelRange = GetEncoderPosition() + (DirFactor*T_DECEL_RANGE_FACTOR);

			///////////////////////////////////////////////
			//  Constant Motor Power After Acceleration  //
			///////////////////////////////////////////////
			TrajectoryState = A_CONST_MTR_PWR_STATE;

			while((DistanceToTargetPosition*DirFactor) > (TranslateDecelRange*DirFactor)
				&& (b_TrajectoryEnabled == true))
			{
				motor[RightMotor] = i*DirFactor;
				motor[LeftMotor] = motor[RightMotor];
				wait1Msec(T_CHANGE_IN_TIME);
				DistanceToTargetPosition = TargetPosition - GetEncoderPosition();
#if DEBUG_AUTONOMOUS_TRANSLATE
				if(T_Index < ARRAY_INDEX)
				{
					T_MtrPwrArray[T_Index] = motor[RightMotor];
					TrajectoryStateArray[T_Index] = TrajectoryState;
					DTTPArray[T_Index] = DistanceToTargetPosition;
					EncoderCountsArray[T_Index] = GetEncoderPosition();
					T_Index++;
				}
#endif
			}

			///////////////////////////////////////////////
			//             Decelerate                    //
			///////////////////////////////////////////////
			TrajectoryState = DECEL_STATE;

			for(;
			(i > MIN_MOTOR_POWER_TRANSLATE) && ((DistanceToTargetPosition*DirFactor) > T_BRAKING_RANGE)
			&& (b_TrajectoryEnabled == true);
			i = i - CHANGE_IN_MTR_PWR
			)
			{
				motor[RightMotor] = i*DirFactor;
				motor[LeftMotor] = motor[RightMotor];
				wait1Msec(T_CHANGE_IN_TIME);
				DistanceToTargetPosition = TargetPosition - GetEncoderPosition();
#if DEBUG_AUTONOMOUS_TRANSLATE
				if(T_Index < ARRAY_INDEX)
				{
					T_MtrPwrArray[T_Index] = motor[RightMotor];
					TrajectoryStateArray[T_Index] = TrajectoryState;
					DTTPArray[T_Index] = DistanceToTargetPosition;
					EncoderCountsArray[T_Index] = GetEncoderPosition();
					T_Index++;
				}
#endif
			}

			///////////////////////////////////////////////
			//  Constant Motor Power After Deceleration  //
			///////////////////////////////////////////////
			TrajectoryState = D_CONST_MTR_PWR_STATE;

			while(((DistanceToTargetPosition*DirFactor) > T_BRAKING_RANGE)
				&& (b_TrajectoryEnabled == true))
			{
				wait1Msec(T_CHANGE_IN_TIME);
				DistanceToTargetPosition = TargetPosition - GetEncoderPosition();
#if DEBUG_AUTONOMOUS_TRANSLATE
				if(T_Index < ARRAY_INDEX)
				{
					T_MtrPwrArray[T_Index] = motor[RightMotor];
					TrajectoryStateArray[T_Index] = TrajectoryState;
					DTTPArray[T_Index] = DistanceToTargetPosition;
					EncoderCountsArray[T_Index] = GetEncoderPosition();
					T_Index++;
				}
#endif
			}

			///////////////////////////////////////////////
			//                   Brake                   //
			///////////////////////////////////////////////
			TrajectoryState = BRAKE_STATE;

			motor[RightMotor] = BRAKE_MTR_PWR*DirFactor;
			motor[LeftMotor] = motor[RightMotor];
			wait1Msec(BRAKE_TIME);
			DistanceToTargetPosition = TargetPosition - GetEncoderPosition();
#if DEBUG_AUTONOMOUS_TRANSLATE
			if(T_Index < ARRAY_INDEX)
			{
				T_MtrPwrArray[T_Index] = motor[RightMotor];
				TrajectoryStateArray[T_Index] = TrajectoryState;
				DTTPArray[T_Index] = DistanceToTargetPosition;
				EncoderCountsArray[T_Index] = GetEncoderPosition();
				T_Index++;
			}
#endif

			///////////////////////////////////////////////
			//              At Target Position           //
			///////////////////////////////////////////////
			TrajectoryState = AT_TARGET_STATE;

			motor[RightMotor] = 0;
			motor[LeftMotor] = 0;

			b_TrajectoryEnabled = false;

#if DEBUG_AUTONOMOUS_TRANSLATE
			if(T_Index < ARRAY_INDEX)
			{
				T_MtrPwrArray[T_Index] = motor[RightMotor];
				TrajectoryStateArray[T_Index] = TrajectoryState;
				DTTPArray[T_Index] = DistanceToTargetPosition;
				EncoderCountsArray[T_Index] = GetEncoderPosition();
				T_Index++;
			}
#endif
		}

		else if(b_TrajectoryEnabled == true && TrajectoryMode == ROTATE)
		{
			motor[LeftMotor] = MIN_MOTOR_POWER_ROTATE*DirFactor;
			motor[RightMotor] = -motor[LeftMotor];

			clearTimer(T1);

#if DEBUG_AUTONOMOUS_ROTATE
			if(Index < ARRAY_INDEX)
			{
				R_MtrPwrArray[Index] = motor[RightMotor];
				AngleArray[Index] = MeasuredAngle;
				RotationRateArray[Index] = CurrentSample;
				Index++;
			}
#endif
			DistanceToTargetAngle = TargetAngle - MeasuredAngle;

			///////////////////////////////////////////////
			//             Accelerate                    //
			///////////////////////////////////////////////
			TrajectoryState = ACCEL_STATE;

			for(i=MIN_MOTOR_POWER_ROTATE;
			i <= (MaxMotorPower - CHANGE_IN_MTR_PWR)
			&& ((DistanceToTargetAngle*DirFactor) > (TargetAngle/2*DirFactor))
			&& (b_TrajectoryEnabled == true);
			i = i + CHANGE_IN_MTR_PWR)
			{
				motor[LeftMotor] = i*DirFactor;
				motor[RightMotor] = -motor[LeftMotor];
				wait1Msec(R_CHANGE_IN_TIME);
				DistanceToTargetAngle = TargetAngle - MeasuredAngle;

#if DEBUG_AUTONOMOUS_ROTATE
				if(Index < ARRAY_INDEX)
				{
					R_MtrPwrArray[Index] = motor[RightMotor];
					AngleArray[Index] = MeasuredAngle;
					RotationRateArray[Index] = CurrentSample;
					Index++;
				}
#endif
			}

			RotateDecelRange = MeasuredAngle + (DirFactor*R_DECEL_RANGE_FACTOR);

			///////////////////////////////////////////////
			//  Constant Motor Power After Acceleration  //
			///////////////////////////////////////////////
			TrajectoryState = A_CONST_MTR_PWR_STATE;

			while((DistanceToTargetAngle*DirFactor) > (RotateDecelRange*DirFactor)
				&& (b_TrajectoryEnabled == true))
			{
				motor[LeftMotor] = i*DirFactor;
				motor[RightMotor] = -motor[LeftMotor];
				wait1Msec(R_CHANGE_IN_TIME);
				DistanceToTargetAngle = TargetAngle - MeasuredAngle;
#if DEBUG_AUTONOMOUS_ROTATE
				if(Index < ARRAY_INDEX)
				{
					R_MtrPwrArray[Index] = motor[RightMotor];
					AngleArray[Index] = MeasuredAngle;
					RotationRateArray[Index] = CurrentSample;
					Index++;
				}
#endif
			}

			///////////////////////////////////////////////
			//             Decelerate                    //
			///////////////////////////////////////////////
			TrajectoryState = DECEL_STATE;

			for(;
			(i > MIN_MOTOR_POWER_ROTATE)
			&& ((DistanceToTargetAngle*DirFactor) > R_BRAKING_RANGE)
			&& (b_TrajectoryEnabled == true);
			i = i - CHANGE_IN_MTR_PWR)
			{
				motor[LeftMotor] = i*DirFactor;
				motor[RightMotor] = -motor[LeftMotor];
				wait1Msec(R_CHANGE_IN_TIME);

				DistanceToTargetAngle = TargetAngle - MeasuredAngle;

#if DEBUG_AUTONOMOUS_ROTATE
				if(Index < ARRAY_INDEX)
				{
					R_MtrPwrArray[Index] = motor[RightMotor];
					AngleArray[Index] = MeasuredAngle;
					RotationRateArray[Index] = CurrentSample;
					Index++;
				}
#endif
			}

			///////////////////////////////////////////////
			//  Constant Motor Power After Deceleration  //
			///////////////////////////////////////////////
			TrajectoryState = D_CONST_MTR_PWR_STATE;

			while((DistanceToTargetAngle*DirFactor) > R_BRAKING_RANGE
				&& (b_TrajectoryEnabled == true))
			{
				wait1Msec(R_CHANGE_IN_TIME);

				DistanceToTargetAngle = TargetAngle - MeasuredAngle;

#if DEBUG_AUTONOMOUS_ROTATE
				if(Index < ARRAY_INDEX)
				{
					R_MtrPwrArray[Index] = motor[RightMotor];
					AngleArray[Index] = MeasuredAngle;
					RotationRateArray[Index] = CurrentSample;
					Index++;
				}
#endif
			}

			///////////////////////////////////////////////
			//                   Brake                   //
			///////////////////////////////////////////////
			TrajectoryState = BRAKE_STATE;

			motor[LeftMotor] = BRAKE_MTR_PWR*DirFactor;
			motor[RightMotor] = -motor[LeftMotor];
			wait1Msec(BRAKE_TIME);

			DistanceToTargetAngle = TargetAngle - MeasuredAngle;

#if DEBUG_AUTONOMOUS_ROTATE
			if(Index < ARRAY_INDEX)
			{
				R_MtrPwrArray[Index] = motor[RightMotor];
				AngleArray[Index] = MeasuredAngle;
				RotationRateArray[Index] = CurrentSample;
				Index++;
			}
#endif

			///////////////////////////////////////////////
			//              At Target Position           //
			///////////////////////////////////////////////
			TrajectoryState = AT_TARGET_STATE;

			motor[RightMotor] = 0;
			motor[LeftMotor] = 0;

			b_TrajectoryEnabled = false;

#if DEBUG_AUTONOMOUS_ROTATE
			if(Index < ARRAY_INDEX)
			{
				R_MtrPwrArray[Index] = motor[RightMotor];
				AngleArray[Index] = MeasuredAngle;
				RotationRateArray[Index] = CurrentSample;
				Index++;
			}
#endif
		}
		else //b_TrajectoryEnabled == false
		{
			TrajectoryState = IDLE_STATE;

#if DEBUG_AUTONOMOUS_ROTATE
			if(Index < ARRAY_INDEX)
			{
				R_MtrPwrArray[Index] = motor[RightMotor];
				AngleArray[Index] = MeasuredAngle;
				RotationRateArray[Index] = CurrentSample;
				Index++;
			}
#endif
#if DEBUG_AUTONOMOUS_TRANSLATE
			if(T_Index < ARRAY_INDEX)
			{
				T_MtrPwrArray[T_Index] = motor[RightMotor];
				TrajectoryStateArray[T_Index] = TrajectoryState;
				DTTPArray[T_Index] = DistanceToTargetPosition;
				EncoderCountsArray[T_Index] = GetEncoderPosition();
				T_Index++;
			}
#endif
			wait1Msec(T_CHANGE_IN_TIME);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of autonomous mode, you may want to perform some initialization on your robot.
// Things that might be performed during initialization include:
//   1. Move motors and servos to a preset position.
//   2. Some sensor types take a short while to reach stable values during which time it is best that
//      robot is not moving. For example, gyro sensor needs a few seconds to obtain the background
//      "bias" value.
//
// In many cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
	ResetGyro();
	CalibrateGyro();
	nMotorEncoder(LifterMotor) = 0;
	servo(LifterServo) = 0;
	servo(GripperServo) = 145;
	servo(GoalServo) = 90;
	servo(HookServo) = 0;
	motor[LeftMotor] = 0;
	motor[RightMotor] = 0;
	nMotorEncoder(LeftMotor) = 0;
	nMotorEncoder(RightMotor) = 0;
	BaseMode = LNR_FULL_MTR_PWR;

	ChooseDelay();

	return;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the autonomous robot operation. Customize as appropriate for
// your specific robot.
//
// The types of things you might do during the autonomous phase (for the 2008-9 FTC competition)
// are:
//
//   1. Have the robot follow a line on the game field until it reaches one of the puck storage
//      areas.
//   2. Load pucks into the robot from the storage bin.
//   3. Stop the robot and wait for autonomous phase to end.
//
// This simple template does nothing except play a periodic tone every few seconds.
//
// At the end of the autonomous period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
//4900
task main()
{
	initializeRobot();

	waitForStart(); // Wait for the beginning of autonomous phase.

	clearTimer(T1);

	startTask(CalculateAngle, 255);
	startTask(TrajectoryGenerator, 90);

	wait1Msec(SecondsToDelay);

	Translate(-4100, 50);
	WaitForMoveToFinish();

	wait1Msec(500);

	Rotate(80, 50); //Turn Right
	WaitForMoveToFinish();

	//wait1Msec(500);

	//Translate(1000, 30);
	//WaitForMoveToFinish();

	wait1Msec(1000);

	Translate(-5000, 20);

	while(b_TrajectoryEnabled == true)
	{
		//nMotorEncoder(RightMotor) = 0;
		//nMotorEncoder(LeftMotor) = 0;

		IRSensorValue = SensorValue(IRSensor);

		//wait1Msec(1000);

		if(IRSensorValue == 8 || IRSensorValue == 7)//Set to 2 for Comp
		{
			wait1Msec(500);
			// Abort Move
			b_TrajectoryEnabled = false;

			// Wait some time to make sure robot is stopped
			// before reading position.
			wait1Msec(1000);

			Position = nMotorEncoder(LeftMotor);
		}
		else
		{
			wait1Msec(500);
		}
	}

	if(abs(Position) > IR_RANGE_2 && abs(Position) <= IR_RANGE_1)
	{
		Translate(700, 30);
		WaitForMoveToFinish();
	}
	else if(abs(Position) <= IR_RANGE_2)
	{

		Translate(-500, 20);
		WaitForMoveToFinish();
		
		wait1Msec(500);
		
		Rotate(-90, 30);
		WaitForMoveToFinish();

		wait1Msec(500);
		
		Translate(-1000, 30);
		WaitForMoveToFinish();
		
		//Translate(-3000, 30);
		//WaitForMoveToFinish();

		//Rotate(-82, 30); //Turn Left
		//WaitForMoveToFinish();

		//wait1Msec(500);

		//Translate(-800, 30);
		//WaitForMoveToFinish();
	}
	else //Position > IR_RANGE_2 (IR_RANGE_3)
	{
		Translate(-680, 30);
		WaitForMoveToFinish();

		Rotate(-85, 30); //Turn Left
		WaitForMoveToFinish();

		Translate(-2600, 30);
		WaitForMoveToFinish();
	}
	if(abs(Position) > IR_RANGE_2 && abs(Position) <= IR_RANGE_1)
	{

		LiftHook();

		Rotate(-55, 30);//84
		WaitForMoveToFinish();

		wait1Msec(1000);

		if(abs(Position) > IR_RANGE_2 && abs(Position) <= IR_RANGE_1)
		{
			Translate(-990, 30);
			WaitForMoveToFinish();
		}
		else if(abs(Position) <= IR_RANGE_2 || abs(Position) > IR_RANGE_1)
		{
			Translate(-980, 30);
			WaitForMoveToFinish();
		}

		else if(abs(Position) > IR_RANGE_1)
		{
			Translate(-500, 30);
			WaitForMoveToFinish();
		}

		Rotate(-32, 30);//84
		WaitForMoveToFinish();

		wait1Msec(1000);

		if(abs(Position) > IR_RANGE_1)
		{
			Translate(2800, 70);
			WaitForMoveToFinish();
		}
		else
		{

			Translate(3800, 70);
			WaitForMoveToFinish();
		}
	}
	else if(abs(Position) <= IR_RANGE_2)
	{
		LiftHook();
		
		wait1Msec(500);
		
		Rotate(-12, 30);
		WaitForMoveToFinish();
		
		wait1Msec(500);
		
		Translate(3000, 50);
		WaitForMoveToFinish();
	}


#if DEBUG_AUTONOMOUS_ROTATE
	for(Index=0; Index<ARRAY_INDEX; Index++)
	{
		wait1Msec(10);
		writeDebugStream("%d,", R_MtrPwrArray[Index]);
		wait1Msec(10);
		writeDebugStream("%f,", AngleArray[Index]);
		wait1Msec(10);
		writeDebugStream("%f\n", RotationRateArray[Index]);
	}
#endif

	/*#if DEBUG_AUTONOMOUS_TRANSLATE
	for(T_Index=0; T_Index<ARRAY_INDEX; T_Index++)
	{
	wait1Msec(20);
	writeDebugStream("%d,", T_MtrPwrArray[T_Index]);
	wait1Msec(20);
	writeDebugStream("%d,", TrajectoryStateArray[T_Index]);
	wait1Msec(20);
	writeDebugStream("%d,", DTTPArray[T_Index]);
	wait1Msec(20);
	writeDebugStream("%d\n", EncoderCountsArray[T_Index]);
	}
#endif*/

}

void CalibrateGyro()
{
	for(i = 0; i<20;i++)
	{
		wait1Msec(10);
		Offset = Offset + SensorValue(GyroSensor);
	}
	Offset = Offset/20;
}

void ResetGyro()
{
	b_TrajectoryEnabled = false;
	TargetAngle = 0;
	CurrentSample = 0;
	PreviousSample = 0;
	MeasuredAngle = 0;
}

void Rotate(long SetTargetAngle, byte SetMaxMotorPower)
{
	ResetGyro();
	TargetAngle = SetTargetAngle;
	MaxMotorPower = SetMaxMotorPower;
	b_TrajectoryEnabled = true;
	TrajectoryMode = ROTATE;

	if(TargetAngle < 0)
	{
		DirFactor = -1;
	}
	else // TargetAngle > 0
	{
		DirFactor = 1;
	}
}

void ResetEncoders()
{
	b_TrajectoryEnabled = false;
	TargetPosition = 0;
	nMotorEncoder[RightMotor] = 0;
	nMotorEncoder[LeftMotor] = 0;
}

int GetEncoderPosition()
{
	return nMotorEncoder[RightMotor];
}

void Translate(int SetTargetPosition, byte SetMaxMotorPower)
{
	ResetEncoders();
	TargetPosition = SetTargetPosition;
	MaxMotorPower = SetMaxMotorPower;
	b_TrajectoryEnabled = true;
	TrajectoryMode = TRANSLATE;

	if(TargetPosition < 0)
	{
		DirFactor = -1;
	}
	else // TargetPosition > 0
	{
		DirFactor = 1;
	}
}

void WaitForMoveToFinish()
{
	while(b_TrajectoryEnabled == true)
	{
		wait1Msec(10);
	}
}

void ChooseDelay()
{
	nButtonPresses = 0;
	eraseDisplay();

	while(nNxtButtonPressed != 3)
	{

		displayCenteredTextLine(1, "Delay Time?");

		displayCenteredBigTextLine(3, "%d", nButtonPresses);

		if(nNxtButtonPressed == 1)
		{
			nButtonPresses += 1;
			displayCenteredBigTextLine(3, "%d", nButtonPresses);
			while(nNxtButtonPressed != -1)//wait for release
			{
				//do nothing
			}
		}

		if(nNxtButtonPressed == 2)
		{
			nButtonPresses -= 1;
			displayCenteredBigTextLine(3, "%d", nButtonPresses);
			while(nNxtButtonPressed != -1)//wait for release
			{
				//do nothing
			}
		}
	}

	SecondsToDelay = nButtonPresses*1000;

	eraseDisplay();

	displayCenteredBigTextLine(3, "%d", SecondsToDelay);

	wait1Msec(1000);

	eraseDisplay();

	return;
}

void LiftHook()
{
	servo[HookServo] = 90;
	wait1Msec(400);
}

/*void ChoosePath()
{
nButtonPresses = 1;
eraseDisplay();

while(nNxtButtonPressed != 0)
{

nxtDisplayCenteredTextLine(1, "Which Path?");

nxtDisplayCenteredBigTextLine(3, "%d", nButtonPresses);

if(nNxtButtonPressed == 3)
{
ChoosePosition();
while(nNxtButtonPressed != -1)//wait for release
{
//do nothing
}
}

if(nNxtButtonPressed == 1 && nButtonPresses <= 4)
{
nButtonPresses += 1;
nxtDisplayCenteredBigTextLine(3, "%d", nButtonPresses);
while(nNxtButtonPressed != -1)//wait for release
{
//do nothing
}
}

if(nNxtButtonPressed == 2 && nButtonPresses >= -5)
{
nButtonPresses -= 1;
nxtDisplayCenteredBigTextLine(3, "%d", nButtonPresses);
while(nNxtButtonPressed != -1)//wait for release
{
//do nothing
}
}
}

SelectedPath = nButtonPresses;

eraseDisplay();

nxtDisplayCenteredBigTextLine(3, "%d", SelectedPath);

wait1Msec(1000);

eraseDisplay();

return;
}*/

//Last stuff//

/*void ChooseDelay()
{
nButtonPresses = 0;
eraseDisplay();

while(nNxtButtonPressed != 0)
{

displayCenteredTextLine(1, "Delay Time?");

displayCenteredBigTextLine(3, "%d", nButtonPresses);

if(nNxtButtonPressed == 1)
{
nButtonPresses += 1;
displayCenteredBigTextLine(3, "%d", nButtonPresses);
while(nNxtButtonPressed != -1)//wait for release
{
//do nothing
}
}

if(nNxtButtonPressed == 2)
{
nButtonPresses -= 1;
displayCenteredBigTextLine(3, "%d", nButtonPresses);
while(nNxtButtonPressed != -1)//wait for release
{
//do nothing
}
}
}

SecondsToDelay = nButtonPresses*1000;

eraseDisplay();

displayCenteredBigTextLine(3, "%d", SecondsToDelay);

//wait1Msec(1000);

//eraseDisplay();

return;
}

void Translate(int SetTargetPosition, byte SetMaxMotorPower)
{
ResetEncoders();
TargetPosition = -SetTargetPosition;
MaxMotorPower_T = SetMaxMotorPower;

nMotorEncoderTarget[RightMotor] = TargetPosition;

motor(RightMotor) = MaxMotorPower_T;
motor(LeftMotor) = MaxMotorPower_T;

while(nMotorRunState(RightMotor) != runStateIdle)
{
//wait until nMotorRunState is equal to runStateIdle
}

motor(RightMotor) = 0;
motor(LeftMotor) = 0;
}

void ResetGyro()
{
TargetAngle = 0;
CurrentSample = 0;
PreviousSample = 0;
MeasuredAngle = 0;
}

void Rotate(long SetTargetAngle, byte SetMaxMotorPower)
{
ResetGyro();
TargetAngle = SetTargetAngle;
MaxMotorPower_R = SetMaxMotorPower;
DistanceToTargetAngle = 0;

if(TargetAngle < 0)//left turn
{
DirFactor = -1;
}
else // TargetAngle > 0 && Right turn
{
DirFactor = 1;
}

while(DistanceToTargetAngle > TargetAngle)
{
motor(LeftMotor) = MaxMotorPower_R * DirFactor;
motor(RightMotor) = -motor(LeftMotor);

CalculateAngle();
DistanceToTargetAngle = TargetAngle - MeasuredAngle;
}

motor(RightMotor) = 0;
motor(RightMotor) = 0;
}

void CalculateAngle()
{
GyroRotation = SensorValue(GyroSensor);
CurrentSample = GyroRotation - Offset;
DegreesThisSample = (CurrentSample + PreviousSample)/2 * ((float)SAMPLE_PERIOD_MSEC/1000);
MeasuredAngle = MeasuredAngle + DegreesThisSample;
PreviousSample = CurrentSample;
wait1Msec(SAMPLE_PERIOD_MSEC);
}

void CalibrateGyro()
{
for(i = 0; i<20;i++)
{
wait1Msec(10);
Offset = Offset + SensorValue(GyroSensor);
}
Offset = Offset/20;
}*/
